pragma solidity ^0.5.0;

import {EVMMemory} from "./EVMMemory.slb";
import {EVMUtils} from "./EVMUtils.slb";

library EVMTStorage {

    using EVMMemory for EVMMemory.Memory;

    struct StorageSlot {
        uint addr;
        EVMMemory.Memory mem;
    }

    struct Element {
        uint _next;
        StorageSlot slot;
    }

    struct Storage {
        Element head;
        uint size;
    }

    function store(Storage memory self, uint cAddr, uint sAddr, uint val) internal pure {
        if (self.size == 0) {
            Element memory e;
            e.slot.addr = cAddr;
            EVMMemory.Memory memory mem = EVMMemory.newMemory();
            mem.store(sAddr, val);
            e.slot.mem = mem;
            self.head = e;
            self.size = 1;
        } else {
            Element memory e = self.head;
            while (true) {
                if (e.slot.addr == cAddr) {
                    e.slot.mem.store(sAddr, val);
                    return;
                }
                if (e._next == 0) {
                    break;
                }
                uint n = e._next;
                assembly {
                    e := n
                }
            }
            EVMMemory.Memory memory mem = EVMMemory.newMemory();
            mem.store(sAddr, val);
            Element memory newElem = Element(0, StorageSlot(cAddr, mem));
            uint elemAddr;
            assembly {
                elemAddr := newElem
            }
            e._next = elemAddr;
            self.size++;
        }
    }

    function load(Storage memory self, uint cAddr, uint sAddr) internal pure returns (uint val) {
        if (self.size != 0) {
            Element memory e = self.head;
            while (true) {
                if (e.slot.addr == cAddr) {
                    return e.slot.mem.load(sAddr);
                }
                if (e._next == 0) {
                    break;
                }
                uint n = e._next;
                assembly {
                    e := n
                }
            }
        }
    }

    function copyToMem(Storage memory self, EVMMemory.Memory memory mem, uint cAddr, uint sAddr, uint mAddr, uint len) internal pure {
        if (self.size != 0) {
            Element memory e = self.head;
            while (true) {
                if (e.slot.addr == cAddr) {
                    mem.storeBytes(e.slot.mem.toArray(sAddr, len), 0, mAddr, len);
                    break;
                }
                if (e._next == 0) { // copy empty
                    bytes memory bts = new bytes(len);
                    mem.storeBytes(bts, 0, mAddr, len);
                    break;
                }
                uint n = e._next;
                assembly {
                    e := n
                }
            }
        }
    }

    function copy(Storage memory self) internal pure returns (Storage memory stg) {
        if (self.size == 0) {
            return stg;
        }
        stg.size = self.size;
        Element memory e = self.head;
        stg.head = Element(0, StorageSlot(e.slot.addr, e.slot.mem.copy()));
        Element memory e2 = stg.head;
        while (true) {
            if (e._next == 0) {
                break;
            }
            uint n = e._next;
            assembly {
                e := n
            }
            Element memory newElem = Element(0, StorageSlot(e.slot.addr, e.slot.mem.copy()));
            uint newElemAddr;
            assembly {
                newElemAddr := newElem
            }
            e2._next = newElemAddr;
            e2 = newElem;
        }
        return stg;
    }

    function toArray(Storage memory self) internal pure returns (uint[] memory arr, bytes memory data) {
        if (self.size == 0) {
            return (arr, data);
        }
        StorageSlot[] memory slots = new StorageSlot[](self.size);
        uint totalSize = 2*self.size;
        Element memory e = self.head;
        uint i = 0;
        uint dataSize = 0;
        while (true) {
            slots[i++] = e.slot;
            dataSize += 32*e.slot.mem.size;
            if (e._next == 0) {
                break;
            }
            uint n = e._next;
            assembly {
                e := n
            }
        }
        arr = new uint[](totalSize);
        data = new bytes(dataSize);
        uint offset = 0;
        uint dataOffset = 0;
        for (i = 0; i < self.size; i++) {
            StorageSlot memory slot = slots[i];
            arr[offset++] = slot.addr;
            arr[offset++] = dataOffset;
            bytes memory bts = slot.mem.toArray();
            EVMUtils.copy(bts, data, 0, dataOffset, bts.length);
            dataOffset += bts.length;
        }
    }

}